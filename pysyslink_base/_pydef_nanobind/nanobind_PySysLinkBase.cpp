#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/ndarray.h>

#include <PySysLinkBase/SimulationModel.h>
#include <PySysLinkBase/ISimulationBlock.h>
#include <PySysLinkBase/IBlockFactory.h>
#include <PySysLinkBase/SpdlogManager.h>
#include <PySysLinkBase/BlockEventsHandler.h>
#include <PySysLinkBase/SimulationManager.h>
#include <PySysLinkBase/ModelParser.h>
#include <PySysLinkBase/SimulationOptions.h>
#include <PySysLinkBase/FullySupportedSignalValue.h>
#include <PySysLinkBase/IBlockEventsHandler.h>
#include <PySysLinkBase/SampleTime.h>
#include <PySysLinkBase/ConfigurationValue.h>
#include <PySysLinkBase/BlockTypeSupportPlugingLoader.h>
#include <PySysLinkBase/SimulationOutput.h>
#include <PySysLinkBase/PortLink.h>
#include <PySysLinkBase/PortsAndSignalValues/InputPort.h>
#include <PySysLinkBase/PortsAndSignalValues/OutputPort.h>
#include <PySysLinkBase/PortsAndSignalValues/Port.h>
#include <PySysLinkBase/PortsAndSignalValues/UnknownTypeSignalValue.h>
#include <PySysLinkBase/PortsAndSignalValues/SignalValue.h>
#include <PySysLinkBase/BlockEvents/BlockEvent.h>
#include <PySysLinkBase/BlockEvents/ValueUpdateBlockEvent.h>
#include <PySysLinkBase/ContinuousAndOde/BasicOdeSolver.h>
#include <PySysLinkBase/ContinuousAndOde/ContinuousState.h>
#include <PySysLinkBase/ContinuousAndOde/SolverFactory.h>
#include <PySysLinkBase/ContinuousAndOde/OdeintStepSolver.h>
#include <PySysLinkBase/ContinuousAndOde/EulerForwardStepSolver.h>
#include <PySysLinkBase/ContinuousAndOde/ISimulationBlockWithContinuousStates.h>
#include <PySysLinkBase/ContinuousAndOde/IOdeStepSolver.h>

namespace nb = nanobind;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class ISimulationBlock_trampoline : public ISimulationBlock
{
public:
    NB_TRAMPOLINE(ISimulationBlock, 8);

    const std::shared_ptr<SampleTime> GetSampleTime() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_sample_time", // function name (python)
            GetSampleTime // function name (c++)
        );
    }
    void SetSampleTime(std::shared_ptr<SampleTime> sampleTime) override
    {
        NB_OVERRIDE_PURE_NAME(
            "set_sample_time", // function name (python)
            SetSampleTime, // function name (c++)
            sampleTime // params
        );
    }
    std::vector<std::shared_ptr<PySysLinkBase::InputPort>> GetInputPorts() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_input_ports", // function name (python)
            GetInputPorts // function name (c++)
        );
    }
    const std::vector<std::shared_ptr<PySysLinkBase::OutputPort>> GetOutputPorts() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_output_ports", // function name (python)
            GetOutputPorts // function name (c++)
        );
    }
    const std::vector<std::shared_ptr<PySysLinkBase::OutputPort>> _ComputeOutputsOfBlock(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double currentTime, bool isMinorStep = false) override
    {
        NB_OVERRIDE_PURE_NAME(
            "_compute_outputs_of_block", // function name (python)
            _ComputeOutputsOfBlock, // function name (c++)
            sampleTime, currentTime, isMinorStep // params
        );
    }
    bool TryUpdateConfigurationValue(std::string keyName, ConfigurationValue value) override
    {
        NB_OVERRIDE_PURE_NAME(
            "try_update_configuration_value", // function name (python)
            TryUpdateConfigurationValue, // function name (c++)
            keyName, value // params
        );
    }
    const std::vector<std::pair<double, double>> GetEvents(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double eventTime, std::vector<double> eventTimeStates) const override
    {
        NB_OVERRIDE_NAME(
            "get_events", // function name (python)
            GetEvents, // function name (c++)
            sampleTime, eventTime, eventTimeStates // params
        );
    }
    const std::vector<double> GetKnownEvents(const std::shared_ptr<PySysLinkBase::SampleTime> resolvedSampleTime, double simulationStartTime, double simulationEndTime) const override
    {
        NB_OVERRIDE_NAME(
            "get_known_events", // function name (python)
            GetKnownEvents, // function name (c++)
            resolvedSampleTime, simulationStartTime, simulationEndTime // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class IBlockEventsHandler_trampoline : public IBlockEventsHandler
{
public:
    NB_TRAMPOLINE(IBlockEventsHandler, 2);

    void BlockEventCallback(const std::shared_ptr<BlockEvent> blockEvent) const override
    {
        NB_OVERRIDE_PURE_NAME(
            "block_event_callback", // function name (python)
            BlockEventCallback, // function name (c++)
            blockEvent // params
        );
    }
    void RegisterValueUpdateBlockEventCallback(std::function<void (std::shared_ptr<ValueUpdateBlockEvent>)> callback) override
    {
        NB_OVERRIDE_PURE_NAME(
            "register_value_update_block_event_callback", // function name (python)
            RegisterValueUpdateBlockEventCallback, // function name (c++)
            callback // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class UnknownTypeSignal_trampoline : public UnknownTypeSignal
{
public:
    NB_TRAMPOLINE(UnknownTypeSignal, 1);

    const std::string GetTypeId() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_type_id", // function name (python)
            GetTypeId // function name (c++)
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class IOdeStepSolver_trampoline : public IOdeStepSolver
{
public:
    NB_TRAMPOLINE(IOdeStepSolver, 1);

    std::tuple<bool, std::vector<double>, double> SolveStep(std::function<std::vector<double>(std::vector<double>, double)> system, std::vector<double> states_0, double currentTime, double timeStep) override
    {
        NB_OVERRIDE_PURE_NAME(
            "solve_step", // function name (python)
            SolveStep, // function name (c++)
            system, states_0, currentTime, timeStep // params
        );
    }
};
}  // namespace PySysLinkBase

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_pysyslink_base(nb::module_& m)
{
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:SimulationModel.h>    ////////////////////
    // #ifndef SRC_SIMULATION_MODEL
    //


    auto pyClassSimulationModel =
        nb::class_<PySysLinkBase::SimulationModel>
            (m, "SimulationModel", "")
        .def_rw("simulation_blocks", &PySysLinkBase::SimulationModel::simulationBlocks, "")
        .def_rw("port_links", &PySysLinkBase::SimulationModel::portLinks, "")
        .def_rw("block_events_handler", &PySysLinkBase::SimulationModel::blockEventsHandler, "")
        .def(nb::init<std::vector<std::shared_ptr<ISimulationBlock>>, std::vector<std::shared_ptr<PortLink>>, std::shared_ptr<IBlockEventsHandler>>(),
            nb::arg("simulation_blocks"), nb::arg("port_links"), nb::arg("block_events_handler"))
        .def("get_connected_ports",
            &PySysLinkBase::SimulationModel::GetConnectedPorts, nb::arg("origin_block"), nb::arg("output_port_index"))
        .def("get_connected_blocks",
            &PySysLinkBase::SimulationModel::GetConnectedBlocks, nb::arg("origin_block"), nb::arg("output_port_index"))
        .def("get_origin_block",
            &PySysLinkBase::SimulationModel::GetOriginBlock, nb::arg("sink_block"), nb::arg("input_port_index"))
        .def("get_direct_block_chains",
            &PySysLinkBase::SimulationModel::GetDirectBlockChains)
        .def("order_block_chains_onto_free_order",
            &PySysLinkBase::SimulationModel::OrderBlockChainsOntoFreeOrder, nb::arg("direct_block_chains"))
        .def("propagate_sample_times",
            &PySysLinkBase::SimulationModel::PropagateSampleTimes)
        ;
    // #endif
    ////////////////////    </generated_from:SimulationModel.h>    ////////////////////


    ////////////////////    <generated_from:ISimulationBlock.h>    ////////////////////
    // #ifndef SRC_ISIMULATION_BLOCK
    //


    auto pyClassISimulationBlock =
        nb::class_<PySysLinkBase::ISimulationBlock, PySysLinkBase::ISimulationBlock_trampoline>
            (m, "ISimulationBlock", "")
        .def("get_id",
            &PySysLinkBase::ISimulationBlock::GetId)
        .def("get_name",
            &PySysLinkBase::ISimulationBlock::GetName)
        .def(nb::init<std::map<std::string, ConfigurationValue>, std::shared_ptr<IBlockEventsHandler>>(),
            nb::arg("block_configuration"), nb::arg("block_events_handler"))
        .def("get_sample_time",
            &PySysLinkBase::ISimulationBlock::GetSampleTime)
        .def("set_sample_time",
            &PySysLinkBase::ISimulationBlock::SetSampleTime, nb::arg("sample_time"))
        .def("get_input_ports",
            &PySysLinkBase::ISimulationBlock::GetInputPorts)
        .def("get_output_ports",
            &PySysLinkBase::ISimulationBlock::GetOutputPorts)
        .def("compute_outputs_of_block",
            &PySysLinkBase::ISimulationBlock::ComputeOutputsOfBlock, nb::arg("sample_time"), nb::arg("current_time"), nb::arg("is_minor_step") = false)
        .def("_compute_outputs_of_block",
            &PySysLinkBase::ISimulationBlock::_ComputeOutputsOfBlock, nb::arg("sample_time"), nb::arg("current_time"), nb::arg("is_minor_step") = false)
        .def("is_block_free_source",
            &PySysLinkBase::ISimulationBlock::IsBlockFreeSource)
        .def("is_input_direct_block_chain_end",
            &PySysLinkBase::ISimulationBlock::IsInputDirectBlockChainEnd, nb::arg("input_index"))
        .def("notify_event",
            &PySysLinkBase::ISimulationBlock::NotifyEvent, nb::arg("block_event"))
        .def("try_update_configuration_value",
            &PySysLinkBase::ISimulationBlock::TryUpdateConfigurationValue, nb::arg("key_name"), nb::arg("value"))
        .def_static("find_block_by_id",
            nb::overload_cast<std::string, const std::vector<std::unique_ptr<PySysLinkBase::ISimulationBlock>> &>(&PySysLinkBase::ISimulationBlock::FindBlockById), nb::arg("id"), nb::arg("blocks_to_find"))
        .def_static("find_block_by_id",
            nb::overload_cast<std::string, const std::vector<std::shared_ptr<PySysLinkBase::ISimulationBlock>> &>(&PySysLinkBase::ISimulationBlock::FindBlockById), nb::arg("id"), nb::arg("blocks_to_find"))
        .def("register_read_inputs_callbacks",
            &PySysLinkBase::ISimulationBlock::RegisterReadInputsCallbacks, nb::arg("callback"))
        .def("register_calculate_output_callbacks",
            &PySysLinkBase::ISimulationBlock::RegisterCalculateOutputCallbacks, nb::arg("callback"))
        .def("get_events",
            &PySysLinkBase::ISimulationBlock::GetEvents, nb::arg("sample_time"), nb::arg("event_time"), nb::arg("event_time_states"))
        .def("get_known_events",
            &PySysLinkBase::ISimulationBlock::GetKnownEvents, nb::arg("resolved_sample_time"), nb::arg("simulation_start_time"), nb::arg("simulation_end_time"))
        ;
    // #endif
    ////////////////////    </generated_from:ISimulationBlock.h>    ////////////////////


    ////////////////////    <generated_from:IBlockFactory.h>    ////////////////////
    ////////////////////    </generated_from:IBlockFactory.h>    ////////////////////


    ////////////////////    <generated_from:SpdlogManager.h>    ////////////////////
    // #ifndef SRC_SPDLOG_MANAGER
    //


    auto pyEnumLogLevel =
        nb::enum_<PySysLinkBase::LogLevel>(m, "LogLevel", nb::is_arithmetic(), "")
            .value("off", PySysLinkBase::off, "")
            .value("debug", PySysLinkBase::debug, "")
            .value("info", PySysLinkBase::info, "")
            .value("warning", PySysLinkBase::warning, "")
            .value("error", PySysLinkBase::error, "")
            .value("critical", PySysLinkBase::critical, "");


    auto pyClassSpdlogManager =
        nb::class_<PySysLinkBase::SpdlogManager>
            (m, "SpdlogManager", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("configure_default_logger",
            &PySysLinkBase::SpdlogManager::ConfigureDefaultLogger)
        .def_static("set_log_level",
            &PySysLinkBase::SpdlogManager::SetLogLevel, nb::arg("log_level"))
        ;
    // #endif
    ////////////////////    </generated_from:SpdlogManager.h>    ////////////////////


    ////////////////////    <generated_from:BlockEventsHandler.h>    ////////////////////
    // #ifndef SRC_BLOCK_EVENTS_HANDLER
    //


    auto pyClassBlockEventsHandler =
        nb::class_<PySysLinkBase::BlockEventsHandler>
            (m, "BlockEventsHandler", "")
        .def(nb::init<>())
        .def("block_event_callback",
            &PySysLinkBase::BlockEventsHandler::BlockEventCallback, nb::arg("block_event"))
        .def("register_value_update_block_event_callback",
            &PySysLinkBase::BlockEventsHandler::RegisterValueUpdateBlockEventCallback, nb::arg("callback"))
        ;
    // #endif
    ////////////////////    </generated_from:BlockEventsHandler.h>    ////////////////////


    ////////////////////    <generated_from:SimulationManager.h>    ////////////////////
    // #ifndef SRC_SIMULATION_MANAGER
    //


    auto pyClassSimulationManager =
        nb::class_<PySysLinkBase::SimulationManager>
            (m, "SimulationManager", "")
        .def(nb::init<std::shared_ptr<SimulationModel>, std::shared_ptr<SimulationOptions>>(),
            nb::arg("simulation_model"), nb::arg("simulation_options"))
        .def("run_simulation",
            &PySysLinkBase::SimulationManager::RunSimulation)
        ;
    // #endif
    ////////////////////    </generated_from:SimulationManager.h>    ////////////////////


    ////////////////////    <generated_from:ModelParser.h>    ////////////////////
    // #ifndef SRC_PY_SYS_LINK_BASE_MODEL_PARSER
    //


    auto pyClassModelParser =
        nb::class_<PySysLinkBase::ModelParser>
            (m, "ModelParser", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("parse_from_yaml",
            &PySysLinkBase::ModelParser::ParseFromYaml, nb::arg("filename"), nb::arg("block_factories"), nb::arg("block_events_handler"))
        ;
    // #endif
    ////////////////////    </generated_from:ModelParser.h>    ////////////////////


    ////////////////////    <generated_from:SimulationOptions.h>    ////////////////////
    // #ifndef SRC_SIMULATION_OPTIONS
    //


    auto pyClassSimulationOptions =
        nb::class_<PySysLinkBase::SimulationOptions>
            (m, "SimulationOptions", "")
        .def(nb::init<>())
        .def_rw("start_time", &PySysLinkBase::SimulationOptions::startTime, "")
        .def_rw("stop_time", &PySysLinkBase::SimulationOptions::stopTime, "")
        .def_rw("run_in_natural_time", &PySysLinkBase::SimulationOptions::runInNaturalTime, "")
        .def_rw("natural_time_speed_multiplier", &PySysLinkBase::SimulationOptions::naturalTimeSpeedMultiplier, "")
        .def_rw("block_ids_input_or_output_and_indexes_to_log", &PySysLinkBase::SimulationOptions::blockIdsInputOrOutputAndIndexesToLog, "")
        .def_rw("solvers_configuration", &PySysLinkBase::SimulationOptions::solversConfiguration, "")
        ;
    // #endif
    ////////////////////    </generated_from:SimulationOptions.h>    ////////////////////


    ////////////////////    <generated_from:FullySupportedSignalValue.h>    ////////////////////
    // #ifndef SRC_FULLY_SUPPORTED_SIGNAL_VALUE
    //
    // #endif
    ////////////////////    </generated_from:FullySupportedSignalValue.h>    ////////////////////


    ////////////////////    <generated_from:IBlockEventsHandler.h>    ////////////////////
    // #ifndef SRC_IBLOCK_EVENTS_HANDLER
    //


    auto pyClassIBlockEventsHandler =
        nb::class_<PySysLinkBase::IBlockEventsHandler, PySysLinkBase::IBlockEventsHandler_trampoline>
            (m, "IBlockEventsHandler", "")
        .def(nb::init<>()) // implicit default constructor
        .def("block_event_callback",
            &PySysLinkBase::IBlockEventsHandler::BlockEventCallback, nb::arg("block_event"))
        .def("register_value_update_block_event_callback",
            &PySysLinkBase::IBlockEventsHandler::RegisterValueUpdateBlockEventCallback, nb::arg("callback"))
        ;
    // #endif
    ////////////////////    </generated_from:IBlockEventsHandler.h>    ////////////////////


    ////////////////////    <generated_from:SampleTime.h>    ////////////////////
    ////////////////////    </generated_from:SampleTime.h>    ////////////////////


    ////////////////////    <generated_from:ConfigurationValue.h>    ////////////////////
    // #ifndef SRC_CONFIGURATION_VALUE
    //


    auto pyClassConfigurationValueManager =
        nb::class_<PySysLinkBase::ConfigurationValueManager>
            (m, "ConfigurationValueManager", "")
        .def(nb::init<>()) // implicit default constructor
        ;
    // #endif
    ////////////////////    </generated_from:ConfigurationValue.h>    ////////////////////


    ////////////////////    <generated_from:BlockTypeSupportPlugingLoader.h>    ////////////////////
    // #ifndef SRC_PY_SYS_LINK_BASE_BLOCK_TYPE_SUPPORT_PLUGING_LOADER
    //


    auto pyClassBlockTypeSupportPlugingLoader =
        nb::class_<PySysLinkBase::BlockTypeSupportPlugingLoader>
            (m, "BlockTypeSupportPlugingLoader", "")
        .def(nb::init<>()) // implicit default constructor
        .def("load_plugins",
            &PySysLinkBase::BlockTypeSupportPlugingLoader::LoadPlugins, nb::arg("plugin_directory"))
        ;
    // #endif
    ////////////////////    </generated_from:BlockTypeSupportPlugingLoader.h>    ////////////////////


    ////////////////////    <generated_from:SimulationOutput.h>    ////////////////////
    // #ifndef SRC_SIMULATION_OUTPUT
    //


    auto pyClassUnknownTypeSignal =
        nb::class_<PySysLinkBase::UnknownTypeSignal, PySysLinkBase::UnknownTypeSignal_trampoline>
            (m, "UnknownTypeSignal", "")
        .def(nb::init<>()) // implicit default constructor
        .def_rw("id", &PySysLinkBase::UnknownTypeSignal::id, "")
        .def_rw("times", &PySysLinkBase::UnknownTypeSignal::times, "")
        .def("get_type_id",
            &PySysLinkBase::UnknownTypeSignal::GetTypeId)
        ;


    auto pyClassSimulationOutput =
        nb::class_<PySysLinkBase::SimulationOutput>
            (m, "SimulationOutput", "")
        .def(nb::init<>()) // implicit default constructor
        .def_rw("signals", &PySysLinkBase::SimulationOutput::signals, "")
        ;
    // #endif
    ////////////////////    </generated_from:SimulationOutput.h>    ////////////////////


    ////////////////////    <generated_from:PortLink.h>    ////////////////////
    // #ifndef SRC_PY_SYS_LINK_BASE_PORT_LINK
    //


    auto pyClassPortLink =
        nb::class_<PySysLinkBase::PortLink>
            (m, "PortLink", "")
        .def(nb::init<std::shared_ptr<ISimulationBlock>, std::shared_ptr<ISimulationBlock>, int, int>(),
            nb::arg("origin_block"), nb::arg("sink_block"), nb::arg("origin_block_port_index"), nb::arg("sink_block_port_index"))
        .def_rw("origin_block", &PySysLinkBase::PortLink::originBlock, "")
        .def_rw("sink_block", &PySysLinkBase::PortLink::sinkBlock, "")
        .def_rw("origin_block_port_index", &PySysLinkBase::PortLink::originBlockPortIndex, "")
        .def_rw("sink_block_port_index", &PySysLinkBase::PortLink::sinkBlockPortIndex, "")
        .def_static("parse_from_config",
            &PySysLinkBase::PortLink::ParseFromConfig, nb::arg("link_configuration"), nb::arg("blocks"))
        ;
    // #endif
    ////////////////////    </generated_from:PortLink.h>    ////////////////////


    ////////////////////    <generated_from:InputPort.h>    ////////////////////
    // #ifndef SRC_PORTS_AND_SIGNAL_VALUES_INPUT_PORT
    //


    auto pyClassInputPort =
        nb::class_<PySysLinkBase::InputPort>
            (m, "InputPort", "")
        .def(nb::init<bool, std::shared_ptr<UnknownTypeSignalValue>>(),
            nb::arg("has_direct_feedthrough"), nb::arg("value"))
        .def("has_direct_feedtrough",
            &PySysLinkBase::InputPort::HasDirectFeedtrough)
        ;
    // #endif
    ////////////////////    </generated_from:InputPort.h>    ////////////////////


    ////////////////////    <generated_from:OutputPort.h>    ////////////////////
    // #ifndef SRC_PORTS_AND_SIGNAL_VALUES_OUTPUT_PORT
    //


    auto pyClassOutputPort =
        nb::class_<PySysLinkBase::OutputPort>
            (m, "OutputPort", "")
        .def(nb::init<std::shared_ptr<UnknownTypeSignalValue>>(),
            nb::arg("value"))
        ;
    // #endif
    ////////////////////    </generated_from:OutputPort.h>    ////////////////////


    ////////////////////    <generated_from:Port.h>    ////////////////////
    // #ifndef SRC_PORTS_AND_SIGNAL_VALUES_PORT
    //


    auto pyClassPort =
        nb::class_<PySysLinkBase::Port>
            (m, "Port", "")
        .def(nb::init<std::shared_ptr<UnknownTypeSignalValue>>(),
            nb::arg("value"))
        .def("try_copy_value_to_port",
            &PySysLinkBase::Port::TryCopyValueToPort, nb::arg("other_port"))
        .def("set_value",
            &PySysLinkBase::Port::SetValue, nb::arg("value"))
        .def("get_value",
            &PySysLinkBase::Port::GetValue)
        .def("__eq__",
            &PySysLinkBase::Port::operator==, nb::arg("rhs"))
        ;
    // #endif
    ////////////////////    </generated_from:Port.h>    ////////////////////


    ////////////////////    <generated_from:UnknownTypeSignalValue.h>    ////////////////////
    ////////////////////    </generated_from:UnknownTypeSignalValue.h>    ////////////////////


    ////////////////////    <generated_from:SignalValue.h>    ////////////////////
    // #ifndef SRC_PY_SYS_LINK_BASE_PORTS_AND_SIGNAL_VALUES_SIGNAL_VALUE
    //
    // #endif
    ////////////////////    </generated_from:SignalValue.h>    ////////////////////


    ////////////////////    <generated_from:BlockEvent.h>    ////////////////////
    // #ifndef SRC_BLOCK_EVENTS_BLOCK_EVENT
    //


    auto pyClassBlockEvent =
        nb::class_<PySysLinkBase::BlockEvent>
            (m, "BlockEvent", "")
        .def_rw("event_type_id", &PySysLinkBase::BlockEvent::eventTypeId, "")
        .def(nb::init<std::string>(),
            nb::arg("event_type_id"))
        ;
    // #endif
    ////////////////////    </generated_from:BlockEvent.h>    ////////////////////


    ////////////////////    <generated_from:ValueUpdateBlockEvent.h>    ////////////////////
    // #ifndef SRC_BLOCK_EVENTS_VALUE_UPDATE_BLOCK_EVENT
    //


    auto pyClassValueUpdateBlockEvent =
        nb::class_<PySysLinkBase::ValueUpdateBlockEvent>
            (m, "ValueUpdateBlockEvent", "")
        .def_rw("simulation_time", &PySysLinkBase::ValueUpdateBlockEvent::simulationTime, "")
        .def_rw("value_id", &PySysLinkBase::ValueUpdateBlockEvent::valueId, "")
        .def_rw("value", &PySysLinkBase::ValueUpdateBlockEvent::value, "")
        .def(nb::init<double, std::string, FullySupportedSignalValue>(),
            nb::arg("simulation_time"), nb::arg("value_id"), nb::arg("value"))
        ;
    // #endif
    ////////////////////    </generated_from:ValueUpdateBlockEvent.h>    ////////////////////


    ////////////////////    <generated_from:BasicOdeSolver.h>    ////////////////////
    // #ifndef SRC_BASIC_ODE_SOLVER
    //


    auto pyClassBasicOdeSolver =
        nb::class_<PySysLinkBase::BasicOdeSolver>
            (m, "BasicOdeSolver", "")
        .def_rw("first_time_step", &PySysLinkBase::BasicOdeSolver::firstTimeStep, "")
        .def("system_model",
            &PySysLinkBase::BasicOdeSolver::SystemModel, nb::arg("states"), nb::arg("time"))
        .def(nb::init<std::shared_ptr<IOdeStepSolver>, std::shared_ptr<SimulationModel>, std::vector<std::shared_ptr<ISimulationBlock>>, std::shared_ptr<SampleTime>, std::shared_ptr<SimulationOptions>, double, bool, double>(),
            nb::arg("ode_step_solver"), nb::arg("simulation_model"), nb::arg("simulation_blocks"), nb::arg("sample_time"), nb::arg("simulation_options"), nb::arg("first_time_step") = 1e-6, nb::arg("activate_events") = true, nb::arg("event_tolerance") = 1e-2)
        .def("update_states_to_next_time_hits",
            &PySysLinkBase::BasicOdeSolver::UpdateStatesToNextTimeHits)
        .def("do_step",
            &PySysLinkBase::BasicOdeSolver::DoStep, nb::arg("current_time"), nb::arg("time_step"))
        .def("compute_major_outputs",
            &PySysLinkBase::BasicOdeSolver::ComputeMajorOutputs, nb::arg("current_time"))
        .def("get_next_time_hit",
            &PySysLinkBase::BasicOdeSolver::GetNextTimeHit)
        .def("get_next_suggested_time_step",
            &PySysLinkBase::BasicOdeSolver::GetNextSuggestedTimeStep)
        ;
    // #endif
    ////////////////////    </generated_from:BasicOdeSolver.h>    ////////////////////


    ////////////////////    <generated_from:ContinuousState.h>    ////////////////////
    ////////////////////    </generated_from:ContinuousState.h>    ////////////////////


    ////////////////////    <generated_from:SolverFactory.h>    ////////////////////
    // #ifndef SRC_CONTINUOUS_AND_ODE_SOLVER_FACTORY
    //


    auto pyClassSolverFactory =
        nb::class_<PySysLinkBase::SolverFactory>
            (m, "SolverFactory", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("create_ode_step_solver",
            &PySysLinkBase::SolverFactory::CreateOdeStepSolver, nb::arg("solver_configuration"))
        ;
    // #endif
    ////////////////////    </generated_from:SolverFactory.h>    ////////////////////


    ////////////////////    <generated_from:OdeintStepSolver.h>    ////////////////////
    // #ifndef SRC_CONTINUOUS_AND_ODE_ODEINT_STEP_SOLVER
    //
    // #endif
    ////////////////////    </generated_from:OdeintStepSolver.h>    ////////////////////


    ////////////////////    <generated_from:EulerForwardStepSolver.h>    ////////////////////
    // #ifndef SRC_EULER_FORWARD_STEP_SOLVER
    //


    auto pyClassEulerForwardStepSolver =
        nb::class_<PySysLinkBase::EulerForwardStepSolver>
            (m, "EulerForwardStepSolver", "")
        .def(nb::init<>()) // implicit default constructor
        .def("solve_step",
            &PySysLinkBase::EulerForwardStepSolver::SolveStep, nb::arg("system"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        ;
    // #endif
    ////////////////////    </generated_from:EulerForwardStepSolver.h>    ////////////////////


    ////////////////////    <generated_from:ISimulationBlockWithContinuousStates.h>    ////////////////////
    ////////////////////    </generated_from:ISimulationBlockWithContinuousStates.h>    ////////////////////


    ////////////////////    <generated_from:IOdeStepSolver.h>    ////////////////////
    // #ifndef SRC_CONTINUOUS_AND_ODE_IODE_STEP_SOLVER
    //


    auto pyClassIOdeStepSolver =
        nb::class_<PySysLinkBase::IOdeStepSolver, PySysLinkBase::IOdeStepSolver_trampoline>
            (m, "IOdeStepSolver", "")
        .def(nb::init<>()) // implicit default constructor
        .def("solve_step",
            &PySysLinkBase::IOdeStepSolver::SolveStep, nb::arg("system"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        ;
    // #endif
    ////////////////////    </generated_from:IOdeStepSolver.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
