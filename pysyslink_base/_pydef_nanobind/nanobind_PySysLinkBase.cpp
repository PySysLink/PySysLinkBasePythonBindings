#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/stl/variant.h>
#include <nanobind/ndarray.h>
#include <nanobind/stl/pair.h>
#include <nanobind/stl/function.h>

#include "SimulationModel.h"
#include "ISimulationBlock.h"
#include "IBlockFactory.h"
#include "SpdlogManager.h"
#include "BlockEventsHandler.h"
#include "SimulationManager.h"
#include "ModelParser.h"
#include "SimulationOptions.h"
#include "FullySupportedSignalValue.h"
#include "IBlockEventsHandler.h"
#include "SampleTime.h"
#include "ConfigurationValue.h"
#include "BlockTypeSupportPluginLoader.h"
#include "SimulationOutput.h"
#include "PortLink.h"
#include "PortsAndSignalValues/InputPort.h"
#include "PortsAndSignalValues/OutputPort.h"
#include "PortsAndSignalValues/Port.h"
#include "PortsAndSignalValues/UnknownTypeSignalValue.h"
#include "PortsAndSignalValues/SignalValue.h"
#include "BlockEvents/BlockEvent.h"
#include "BlockEvents/ValueUpdateBlockEvent.h"
#include "ContinuousAndOde/BasicOdeSolver.h"
#include "ContinuousAndOde/SolverFactory.h"
#include "ContinuousAndOde/OdeintStepSolver.h"
#include "ContinuousAndOde/EulerForwardStepSolver.h"
#include "ContinuousAndOde/EulerBackwardStepSolver.h"
#include "ContinuousAndOde/ISimulationBlockWithContinuousStates.h"
#include "ContinuousAndOde/IOdeStepSolver.h"

namespace nb = nanobind;



using PairOfDoubles = std::pair<double, double>;
using OdeStepReturnType = std::tuple<bool, std::vector<double>, double>;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class IOdeStepSolver_trampoline : public IOdeStepSolver
{
public:
    NB_TRAMPOLINE(IOdeStepSolver, 3);

    bool IsJacobianNeeded() const override
    {
        NB_OVERRIDE_NAME(
            "is_jacobian_needed", // function name (python)
            IsJacobianNeeded // function name (c++)
        );
    }
    OdeStepReturnType SolveStep(std::function<std::vector<double>(std::vector<double>, double)> system, std::vector<double> states_0, double currentTime, double timeStep) override
    {
        NB_OVERRIDE_PURE_NAME(
            "solve_step", // function name (python)
            SolveStep, // function name (c++)
            system, states_0, currentTime, timeStep // params
        );
    }
    OdeStepReturnType SolveStep(std::function<std::vector<double>(std::vector<double>, double)> systemDerivatives, std::function<std::vector<std::vector<double> >(std::vector<double>, double)> systemJacobian, std::vector<double> states_0, double currentTime, double timeStep) override
    {
        NB_OVERRIDE_NAME(
            "solve_step", // function name (python)
            SolveStep, // function name (c++)
            systemDerivatives, systemJacobian, states_0, currentTime, timeStep // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class UnknownTypeSignalValue_trampoline : public UnknownTypeSignalValue
{
public:
    NB_TRAMPOLINE(UnknownTypeSignalValue, 2);

    const std::string GetTypeId() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_type_id", // function name (python)
            GetTypeId // function name (c++)
        );
    }
    std::unique_ptr<PySysLinkBase::UnknownTypeSignalValue> clone() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "clone", // function name (python)
            clone // function name (c++)
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class IBlockEventsHandler_trampoline : public IBlockEventsHandler
{
public:
    NB_TRAMPOLINE(IBlockEventsHandler, 2);

    void BlockEventCallback(const std::shared_ptr<PySysLinkBase::BlockEvent> blockEvent) const override
    {
        NB_OVERRIDE_PURE_NAME(
            "block_event_callback", // function name (python)
            BlockEventCallback, // function name (c++)
            blockEvent // params
        );
    }
    void RegisterValueUpdateBlockEventCallback(std::function<void (std::shared_ptr<PySysLinkBase::ValueUpdateBlockEvent>)> callback) override
    {
        NB_OVERRIDE_PURE_NAME(
            "register_value_update_block_event_callback", // function name (python)
            RegisterValueUpdateBlockEventCallback, // function name (c++)
            callback // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class BlockEventsHandler_trampoline : public BlockEventsHandler
{
public:
    NB_TRAMPOLINE(BlockEventsHandler, 2);

    void BlockEventCallback(const std::shared_ptr<PySysLinkBase::BlockEvent> blockEvent) const override
    {
        NB_OVERRIDE_PURE_NAME(
            "block_event_callback", // function name (python)
            BlockEventCallback, // function name (c++)
            blockEvent // params
        );
    }
    void RegisterValueUpdateBlockEventCallback(std::function<void (std::shared_ptr<PySysLinkBase::ValueUpdateBlockEvent>)> callback) override
    {
        NB_OVERRIDE_PURE_NAME(
            "register_value_update_block_event_callback", // function name (python)
            RegisterValueUpdateBlockEventCallback, // function name (c++)
            callback // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class UnknownTypeSignal_trampoline : public UnknownTypeSignal
{
public:
    NB_TRAMPOLINE(UnknownTypeSignal, 1);

    const std::string GetTypeId() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_type_id", // function name (python)
            GetTypeId // function name (c++)
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class EulerForwardStepSolver_trampoline : public EulerForwardStepSolver
{
public:
    NB_TRAMPOLINE(EulerForwardStepSolver, 3);

    OdeStepReturnType SolveStep(std::function<std::vector<double>(std::vector<double>, double)> system, std::vector<double> states_0, double currentTime, double timeStep) override
    {
        NB_OVERRIDE_NAME(
            "solve_step", // function name (python)
            SolveStep, // function name (c++)
            system, states_0, currentTime, timeStep // params
        );
    }
    bool IsJacobianNeeded() const override
    {
        NB_OVERRIDE_NAME(
            "is_jacobian_needed", // function name (python)
            IsJacobianNeeded // function name (c++)
        );
    }
    OdeStepReturnType SolveStep(std::function<std::vector<double>(std::vector<double>, double)> systemDerivatives, std::function<std::vector<std::vector<double> >(std::vector<double>, double)> systemJacobian, std::vector<double> states_0, double currentTime, double timeStep) override
    {
        NB_OVERRIDE_NAME(
            "solve_step", // function name (python)
            SolveStep, // function name (c++)
            systemDerivatives, systemJacobian, states_0, currentTime, timeStep // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class ISimulationBlock_trampoline : public ISimulationBlock
{
public:
    NB_TRAMPOLINE(ISimulationBlock, 8);

    const std::shared_ptr<PySysLinkBase::SampleTime> GetSampleTime() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_sample_time", // function name (python)
            GetSampleTime // function name (c++)
        );
    }
    void SetSampleTime(std::shared_ptr<PySysLinkBase::SampleTime> sampleTime) override
    {
        NB_OVERRIDE_PURE_NAME(
            "set_sample_time", // function name (python)
            SetSampleTime, // function name (c++)
            sampleTime // params
        );
    }
    std::vector<std::shared_ptr<PySysLinkBase::InputPort> > GetInputPorts() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_input_ports", // function name (python)
            GetInputPorts // function name (c++)
        );
    }
    const std::vector<std::shared_ptr<PySysLinkBase::OutputPort> > GetOutputPorts() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_output_ports", // function name (python)
            GetOutputPorts // function name (c++)
        );
    }
    const std::vector<std::shared_ptr<PySysLinkBase::OutputPort> > _ComputeOutputsOfBlock(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double currentTime, bool isMinorStep = false) override
    {
        NB_OVERRIDE_PURE_NAME(
            "_compute_outputs_of_block", // function name (python)
            _ComputeOutputsOfBlock, // function name (c++)
            sampleTime, currentTime, isMinorStep // params
        );
    }
    bool _TryUpdateConfigurationValue(std::string keyName, ConfigurationValue value) override
    {
        NB_OVERRIDE_PURE_NAME(
            "_try_update_configuration_value", // function name (python)
            _TryUpdateConfigurationValue, // function name (c++)
            keyName, value // params
        );
    }
    const std::vector<PairOfDoubles > GetEvents(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double eventTime, std::vector<double> eventTimeStates, bool includeKnownEvents = false) const override
    {
        NB_OVERRIDE_NAME(
            "get_events", // function name (python)
            GetEvents, // function name (c++)
            sampleTime, eventTime, eventTimeStates, includeKnownEvents // params
        );
    }
    const std::vector<double> GetKnownEvents(const std::shared_ptr<PySysLinkBase::SampleTime> resolvedSampleTime, double simulationStartTime, double simulationEndTime) const override
    {
        NB_OVERRIDE_NAME(
            "get_known_events", // function name (python)
            GetKnownEvents, // function name (c++)
            resolvedSampleTime, simulationStartTime, simulationEndTime // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class IBlockFactory_trampoline : public IBlockFactory
{
public:
    NB_TRAMPOLINE(IBlockFactory, 1);

    std::shared_ptr<PySysLinkBase::ISimulationBlock> CreateBlock(std::map<std::string, ConfigurationValue> blockConfiguration, std::shared_ptr<PySysLinkBase::IBlockEventsHandler> blockEventsHandler) override
    {
        NB_OVERRIDE_PURE_NAME(
            "create_block", // function name (python)
            CreateBlock, // function name (c++)
            blockConfiguration, blockEventsHandler // params
        );
    }
};
}  // namespace PySysLinkBase

namespace PySysLinkBase {
// helper type to enable overriding virtual methods in python
class ISimulationBlockWithContinuousStates_trampoline : public ISimulationBlockWithContinuousStates
{
public:
    NB_TRAMPOLINE(ISimulationBlockWithContinuousStates, 11);

    const std::vector<double> GetContinuousStates() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_continuous_states", // function name (python)
            GetContinuousStates // function name (c++)
        );
    }
    void SetContinuousStates(std::vector<double> newStates) override
    {
        NB_OVERRIDE_PURE_NAME(
            "set_continuous_states", // function name (python)
            SetContinuousStates, // function name (c++)
            newStates // params
        );
    }
    const std::vector<double> GetContinuousStateDerivatives(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double currentTime) const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_continuous_state_derivatives", // function name (python)
            GetContinuousStateDerivatives, // function name (c++)
            sampleTime, currentTime // params
        );
    }
    const std::shared_ptr<PySysLinkBase::SampleTime> GetSampleTime() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_sample_time", // function name (python)
            GetSampleTime // function name (c++)
        );
    }
    void SetSampleTime(std::shared_ptr<PySysLinkBase::SampleTime> sampleTime) override
    {
        NB_OVERRIDE_PURE_NAME(
            "set_sample_time", // function name (python)
            SetSampleTime, // function name (c++)
            sampleTime // params
        );
    }
    std::vector<std::shared_ptr<PySysLinkBase::InputPort> > GetInputPorts() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_input_ports", // function name (python)
            GetInputPorts // function name (c++)
        );
    }
    const std::vector<std::shared_ptr<PySysLinkBase::OutputPort> > GetOutputPorts() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_output_ports", // function name (python)
            GetOutputPorts // function name (c++)
        );
    }
    const std::vector<std::shared_ptr<PySysLinkBase::OutputPort> > _ComputeOutputsOfBlock(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double currentTime, bool isMinorStep = false) override
    {
        NB_OVERRIDE_PURE_NAME(
            "_compute_outputs_of_block", // function name (python)
            _ComputeOutputsOfBlock, // function name (c++)
            sampleTime, currentTime, isMinorStep // params
        );
    }
    bool _TryUpdateConfigurationValue(std::string keyName, ConfigurationValue value) override
    {
        NB_OVERRIDE_PURE_NAME(
            "_try_update_configuration_value", // function name (python)
            _TryUpdateConfigurationValue, // function name (c++)
            keyName, value // params
        );
    }
    const std::vector<PairOfDoubles > GetEvents(const std::shared_ptr<PySysLinkBase::SampleTime> sampleTime, double eventTime, std::vector<double> eventTimeStates, bool includeKnownEvents = false) const override
    {
        NB_OVERRIDE_NAME(
            "get_events", // function name (python)
            GetEvents, // function name (c++)
            sampleTime, eventTime, eventTimeStates, includeKnownEvents // params
        );
    }
    const std::vector<double> GetKnownEvents(const std::shared_ptr<PySysLinkBase::SampleTime> resolvedSampleTime, double simulationStartTime, double simulationEndTime) const override
    {
        NB_OVERRIDE_NAME(
            "get_known_events", // function name (python)
            GetKnownEvents, // function name (c++)
            resolvedSampleTime, simulationStartTime, simulationEndTime // params
        );
    }
};
}  // namespace PySysLinkBase

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_pysyslink_base(nb::module_& m)
{
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
using namespace PySysLinkBase;
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:test.h>    ////////////////////
    // #ifndef AMALGAMATED_HEADER_H
    //


    auto pyClassBlockEvent =
        nb::class_<PySysLinkBase::BlockEvent>
            (m, "BlockEvent", "")
        .def_rw("event_type_id", &PySysLinkBase::BlockEvent::eventTypeId, "")
        .def(nb::init<std::string>(),
            nb::arg("event_type_id"))
        ;


    auto pyClassIOdeStepSolver =
        nb::class_<PySysLinkBase::IOdeStepSolver, PySysLinkBase::IOdeStepSolver_trampoline>
            (m, "IOdeStepSolver", "")
        .def(nb::init<>()) // implicit default constructor
        .def("is_jacobian_needed",
            &PySysLinkBase::IOdeStepSolver::IsJacobianNeeded)
        .def("solve_step",
            nb::overload_cast<std::function<std::vector<double>(std::vector<double>, double)>, std::vector<double>, double, double>(&PySysLinkBase::IOdeStepSolver::SolveStep), nb::arg("system"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        .def("solve_step",
            nb::overload_cast<std::function<std::vector<double>(std::vector<double>, double)>, std::function<std::vector<std::vector<double> >(std::vector<double>, double)>, std::vector<double>, double, double>(&PySysLinkBase::IOdeStepSolver::SolveStep), nb::arg("system_derivatives"), nb::arg("system_jacobian"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        ;


    auto pyClassUnknownTypeSignalValue =
        nb::class_<PySysLinkBase::UnknownTypeSignalValue, PySysLinkBase::UnknownTypeSignalValue_trampoline>
            (m, "UnknownTypeSignalValue", "")
        .def(nb::init<>()) // implicit default constructor
        .def("get_type_id",
            &PySysLinkBase::UnknownTypeSignalValue::GetTypeId)
        .def("try_cast_to_typed",
            [](PySysLinkBase::UnknownTypeSignalValue & self) { return self.TryCastToTyped<double>(); })
        .def("try_cast_to_typed",
            [](PySysLinkBase::UnknownTypeSignalValue & self) { return self.TryCastToTyped<std::complex<double> >(); })
        .def("clone",
            &PySysLinkBase::UnknownTypeSignalValue::clone)
        ;


    auto pyEnumLogLevel =
        nb::enum_<PySysLinkBase::LogLevel>(m, "LogLevel", nb::is_arithmetic(), "")
            .value("off", PySysLinkBase::off, "")
            .value("debug", PySysLinkBase::debug, "")
            .value("info", PySysLinkBase::info, "")
            .value("warning", PySysLinkBase::warning, "")
            .value("error", PySysLinkBase::error, "")
            .value("critical", PySysLinkBase::critical, "");


    auto pyClassSpdlogManager =
        nb::class_<PySysLinkBase::SpdlogManager>
            (m, "SpdlogManager", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("configure_default_logger",
            &PySysLinkBase::SpdlogManager::ConfigureDefaultLogger)
        .def_static("set_log_level",
            &PySysLinkBase::SpdlogManager::SetLogLevel, nb::arg("log_level"))
        ;


    auto pyEnumSampleTimeType =
        nb::enum_<PySysLinkBase::SampleTimeType>(m, "SampleTimeType", nb::is_arithmetic(), "")
            .value("continuous", PySysLinkBase::continuous, "")
            .value("discrete", PySysLinkBase::discrete, "")
            .value("constant", PySysLinkBase::constant, "")
            .value("inherited", PySysLinkBase::inherited, "")
            .value("multirate", PySysLinkBase::multirate, "");


    auto pyClassSampleTime =
        nb::class_<PySysLinkBase::SampleTime>
            (m, "SampleTime", "")
        .def(nb::init<PySysLinkBase::SampleTimeType, double, int, std::vector<PySysLinkBase::SampleTimeType>, std::vector<std::shared_ptr<PySysLinkBase::SampleTime> >, int, int>(),
            nb::arg("sample_time_type"), nb::arg("discrete_sample_time"), nb::arg("continuous_sample_time_group"), nb::arg("supported_sample_time_types_for_inheritance"), nb::arg("multirate_sample_times"), nb::arg("input_multirate_sample_time_index") = -1, nb::arg("output_multirate_sample_time_index") = -1)
        .def(nb::init<PySysLinkBase::SampleTimeType>(),
            nb::arg("sample_time_type"))
        .def(nb::init<PySysLinkBase::SampleTimeType, double>(),
            nb::arg("sample_time_type"), nb::arg("discrete_sample_time"))
        .def(nb::init<PySysLinkBase::SampleTimeType, int>(),
            nb::arg("sample_time_type"), nb::arg("continuous_sample_time_group"))
        .def(nb::init<PySysLinkBase::SampleTimeType, std::vector<PySysLinkBase::SampleTimeType> >(),
            nb::arg("sample_time_type"), nb::arg("supported_sample_time_types_for_inheritance"))
        .def(nb::init<PySysLinkBase::SampleTimeType, std::vector<std::shared_ptr<PySysLinkBase::SampleTime> > >(),
            nb::arg("sample_time_type"), nb::arg("multirate_sample_times"))
        .def(nb::init<PySysLinkBase::SampleTimeType, std::vector<std::shared_ptr<PySysLinkBase::SampleTime> >, int, int>(),
            nb::arg("sample_time_type"), nb::arg("multirate_sample_times"), nb::arg("input_multirate_sample_time_index"), nb::arg("output_multirate_sample_time_index"))
        .def("get_sample_time_type",
            &PySysLinkBase::SampleTime::GetSampleTimeType)
        .def("get_discrete_sample_time",
            &PySysLinkBase::SampleTime::GetDiscreteSampleTime)
        .def("get_continuous_sample_time_group",
            &PySysLinkBase::SampleTime::GetContinuousSampleTimeGroup)
        .def("get_supported_sample_time_types_for_inheritance",
            &PySysLinkBase::SampleTime::GetSupportedSampleTimeTypesForInheritance)
        .def("get_multirate_sample_times",
            &PySysLinkBase::SampleTime::GetMultirateSampleTimes)
        .def("set_multirate_sample_time_in_index",
            &PySysLinkBase::SampleTime::SetMultirateSampleTimeInIndex, nb::arg("multirate_sample_time"), nb::arg("index"))
        .def("has_multirate_inherited_sample_time",
            &PySysLinkBase::SampleTime::HasMultirateInheritedSampleTime)
        .def("get_input_multirate_sample_time_index",
            &PySysLinkBase::SampleTime::GetInputMultirateSampleTimeIndex)
        .def("get_output_multirate_sample_time_index",
            &PySysLinkBase::SampleTime::GetOutputMultirateSampleTimeIndex)
        .def("is_input_multirate_inherited",
            &PySysLinkBase::SampleTime::IsInputMultirateInherited)
        .def("is_output_multirate_inherited",
            &PySysLinkBase::SampleTime::IsOutputMultirateInherited)
        .def_static("sample_time_type_string",
            &PySysLinkBase::SampleTime::SampleTimeTypeString, nb::arg("sample_time_type"))
        ;


    auto pyClassIBlockEventsHandler =
        nb::class_<PySysLinkBase::IBlockEventsHandler, PySysLinkBase::IBlockEventsHandler_trampoline>
            (m, "IBlockEventsHandler", "")
        .def(nb::init<>()) // implicit default constructor
        .def("block_event_callback",
            &PySysLinkBase::IBlockEventsHandler::BlockEventCallback, nb::arg("block_event"))
        .def("register_value_update_block_event_callback",
            &PySysLinkBase::IBlockEventsHandler::RegisterValueUpdateBlockEventCallback, nb::arg("callback"))
        ;


    m.def("convert_to_fully_supported_signal_value",
        PySysLinkBase::ConvertToFullySupportedSignalValue, nb::arg("unknown_value"));


    auto pyClassConfigurationValueManager =
        nb::class_<PySysLinkBase::ConfigurationValueManager>
            (m, "ConfigurationValueManager", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("try_get_configuration_value",
            nb::overload_cast<std::string, std::map<std::string, ConfigurationValue> >(&PySysLinkBase::ConfigurationValueManager::TryGetConfigurationValue<bool>), nb::arg("key_name"), nb::arg("configuration_values"))
        .def_static("try_get_configuration_value",
            nb::overload_cast<std::string, std::map<std::string, ConfigurationValue> >(&PySysLinkBase::ConfigurationValueManager::TryGetConfigurationValue<int>), nb::arg("key_name"), nb::arg("configuration_values"))
        .def_static("try_get_configuration_value",
            nb::overload_cast<std::string, std::map<std::string, ConfigurationValue> >(&PySysLinkBase::ConfigurationValueManager::TryGetConfigurationValue<double>), nb::arg("key_name"), nb::arg("configuration_values"))
        .def_static("try_get_configuration_value",
            nb::overload_cast<std::string, std::map<std::string, ConfigurationValue> >(&PySysLinkBase::ConfigurationValueManager::TryGetConfigurationValue<std::complex<double> >), nb::arg("key_name"), nb::arg("configuration_values"))
        ;


    auto pyClassSimulationOptions =
        nb::class_<PySysLinkBase::SimulationOptions>
            (m, "SimulationOptions", "")
        .def(nb::init<>())
        .def_rw("start_time", &PySysLinkBase::SimulationOptions::startTime, "")
        .def_rw("stop_time", &PySysLinkBase::SimulationOptions::stopTime, "")
        .def_rw("run_in_natural_time", &PySysLinkBase::SimulationOptions::runInNaturalTime, "")
        .def_rw("natural_time_speed_multiplier", &PySysLinkBase::SimulationOptions::naturalTimeSpeedMultiplier, "")
        .def_rw("block_ids_input_or_output_and_indexes_to_log", &PySysLinkBase::SimulationOptions::blockIdsInputOrOutputAndIndexesToLog, "")
        .def_rw("solvers_configuration", &PySysLinkBase::SimulationOptions::solversConfiguration, "")
        .def_rw("hdf5_file_name", &PySysLinkBase::SimulationOptions::hdf5FileName, "")
        .def_rw("save_to_file_continuously", &PySysLinkBase::SimulationOptions::saveToFileContinuously, "")
        .def_rw("save_to_vectors", &PySysLinkBase::SimulationOptions::saveToVectors, "")
        ;


    auto pyClassBlockEventsHandler =
        nb::class_<PySysLinkBase::BlockEventsHandler, PySysLinkBase::IBlockEventsHandler, PySysLinkBase::BlockEventsHandler_trampoline>
            (m, "BlockEventsHandler", "")
        .def(nb::init<>())
        .def("block_event_callback",
            &PySysLinkBase::BlockEventsHandler::BlockEventCallback, nb::arg("block_event"))
        .def("register_value_update_block_event_callback",
            &PySysLinkBase::BlockEventsHandler::RegisterValueUpdateBlockEventCallback, nb::arg("callback"))
        ;


    auto pyClassValueUpdateBlockEvent =
        nb::class_<PySysLinkBase::ValueUpdateBlockEvent, PySysLinkBase::BlockEvent>
            (m, "ValueUpdateBlockEvent", "")
        .def_rw("simulation_time", &PySysLinkBase::ValueUpdateBlockEvent::simulationTime, "")
        .def_rw("value_id", &PySysLinkBase::ValueUpdateBlockEvent::valueId, "")
        .def_rw("value", &PySysLinkBase::ValueUpdateBlockEvent::value, "")
        .def(nb::init<double, std::string, FullySupportedSignalValue>(),
            nb::arg("simulation_time"), nb::arg("value_id"), nb::arg("value"))
        ;


    auto pyClassEulerBackwardStepSolver =
        nb::class_<PySysLinkBase::EulerBackwardStepSolver, PySysLinkBase::IOdeStepSolver>
            (m, "EulerBackwardStepSolver", "")
        .def(nb::init<double, double>(),
            nb::arg("maximum_iterations") = 50, nb::arg("tolerance") = 1e-6)
        .def("solve_step",
            nb::overload_cast<std::function<std::vector<double>(std::vector<double>, double)>, std::vector<double>, double, double>(&PySysLinkBase::EulerBackwardStepSolver::SolveStep), nb::arg("system"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        .def("solve_step",
            nb::overload_cast<std::function<std::vector<double>(std::vector<double>, double)>, std::function<std::vector<std::vector<double> >(std::vector<double>, double)>, std::vector<double>, double, double>(&PySysLinkBase::EulerBackwardStepSolver::SolveStep), nb::arg("system_derivatives"), nb::arg("system_jacobian"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        .def("is_jacobian_needed",
            &PySysLinkBase::EulerBackwardStepSolver::IsJacobianNeeded)
        ;


    m.def("escape_json",
        PySysLinkBase::escapeJson, nb::arg("s"));


    auto pyClassUnknownTypeSignal =
        nb::class_<PySysLinkBase::UnknownTypeSignal, PySysLinkBase::UnknownTypeSignal_trampoline>
            (m, "UnknownTypeSignal", "")
        .def_rw("id", &PySysLinkBase::UnknownTypeSignal::id, "")
        .def_rw("times", &PySysLinkBase::UnknownTypeSignal::times, "")
        .def(nb::init<>(),
            "Reserve capacity upfront")
        .def("get_type_id",
            &PySysLinkBase::UnknownTypeSignal::GetTypeId)
        .def("try_cast_to_typed",
            [](PySysLinkBase::UnknownTypeSignal & self) { return self.TryCastToTyped<double>(); })
        .def("try_cast_to_typed",
            [](PySysLinkBase::UnknownTypeSignal & self) { return self.TryCastToTyped<std::complex<double> >(); })
        .def("try_insert_value",
            nb::overload_cast<double, double>(&PySysLinkBase::UnknownTypeSignal::TryInsertValue<double>), nb::arg("time"), nb::arg("value"))
        .def("try_insert_value",
            nb::overload_cast<double, std::complex<double> >(&PySysLinkBase::UnknownTypeSignal::TryInsertValue<std::complex<double> >), nb::arg("time"), nb::arg("value"))
        ;


    auto pyClassSignal_double =
        nb::class_<PySysLinkBase::Signal<double>, PySysLinkBase::UnknownTypeSignal>
            (m, "Signal_double", "")
        .def_rw("values", &PySysLinkBase::Signal<double>::values, "")
        .def(nb::init<>())
        .def("get_type_id",
            &PySysLinkBase::Signal<double>::GetTypeId, "Cache type ID to avoid repeated allocations")
        ;
    auto pyClassSignal_complex_double =
        nb::class_<PySysLinkBase::Signal<std::complex<double> >, PySysLinkBase::UnknownTypeSignal>
            (m, "Signal_complex_double", "")
        .def_rw("values", &PySysLinkBase::Signal<std::complex<double> >::values, "")
        .def(nb::init<>())
        .def("get_type_id",
            &PySysLinkBase::Signal<std::complex<double> >::GetTypeId, "Cache type ID to avoid repeated allocations")
        ;


    auto pyClassSimulationOutput =
        nb::class_<PySysLinkBase::SimulationOutput>
            (m, "SimulationOutput", "")
        .def(nb::init<bool, bool, std::string>(),
            nb::arg("save_to_vectors") = true, nb::arg("save_to_file_continuously") = false, nb::arg("hdf5_file_name") = "")
        .def_rw("signals", &PySysLinkBase::SimulationOutput::signals, "")
        .def("insert_unknown_value",
            &PySysLinkBase::SimulationOutput::InsertUnknownValue, nb::arg("signal_type"), nb::arg("signal_id"), nb::arg("value"), nb::arg("current_time"))
        .def("insert_fully_supported_value",
            &PySysLinkBase::SimulationOutput::InsertFullySupportedValue, nb::arg("signal_type"), nb::arg("signal_id"), nb::arg("value"), nb::arg("current_time"))
        .def("write_json",
            &PySysLinkBase::SimulationOutput::WriteJson, nb::arg("filename"))
        ;


    auto pyClassEulerForwardStepSolver =
        nb::class_<PySysLinkBase::EulerForwardStepSolver, PySysLinkBase::IOdeStepSolver, PySysLinkBase::EulerForwardStepSolver_trampoline>
            (m, "EulerForwardStepSolver", "")
        .def(nb::init<>()) // implicit default constructor
        .def("solve_step",
            nb::overload_cast<std::function<std::vector<double>(std::vector<double>, double)>, std::vector<double>, double, double>(&PySysLinkBase::EulerForwardStepSolver::SolveStep), nb::arg("system"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        .def("is_jacobian_needed",
            &PySysLinkBase::EulerForwardStepSolver::IsJacobianNeeded)
        .def("solve_step",
            nb::overload_cast<std::function<std::vector<double>(std::vector<double>, double)>, std::function<std::vector<std::vector<double> >(std::vector<double>, double)>, std::vector<double>, double, double>(&PySysLinkBase::EulerForwardStepSolver::SolveStep), nb::arg("system_derivatives"), nb::arg("system_jacobian"), nb::arg("states_0"), nb::arg("current_time"), nb::arg("time_step"))
        ;


    auto pyClassPort =
        nb::class_<PySysLinkBase::Port>
            (m, "Port", "")
        .def(nb::init<std::shared_ptr<PySysLinkBase::UnknownTypeSignalValue> >(),
            nb::arg("value"))
        .def("try_copy_value_to_port",
            &PySysLinkBase::Port::TryCopyValueToPort, nb::arg("other_port"))
        .def("set_value",
            &PySysLinkBase::Port::SetValue, nb::arg("value"))
        .def("get_value",
            &PySysLinkBase::Port::GetValue)
        .def("__eq__",
            &PySysLinkBase::Port::operator==, nb::arg("rhs"))
        ;


    auto pyClassSignalValue_double =
        nb::class_<PySysLinkBase::SignalValue<double>, PySysLinkBase::UnknownTypeSignalValue>
            (m, "SignalValue_double", "")
        .def(nb::init<double>(),
            nb::arg("initial_payload"))
        .def(nb::init<const PySysLinkBase::SignalValue<double > &>(),
            nb::arg("other"))
        .def("clone",
            &PySysLinkBase::SignalValue<double >::clone)
        .def("get_type_id",
            &PySysLinkBase::SignalValue<double>::GetTypeId)
        .def("get_payload",
            &PySysLinkBase::SignalValue<double>::GetPayload)
        .def("set_payload",
            &PySysLinkBase::SignalValue<double>::SetPayload, nb::arg("new_payload"))
        ;
    auto pyClassSignalValue_complex_double =
        nb::class_<PySysLinkBase::SignalValue<std::complex<double> >, PySysLinkBase::UnknownTypeSignalValue>
            (m, "SignalValue_complex_double", "")
        .def(nb::init<std::complex<double> >(),
            nb::arg("initial_payload"))
        .def(nb::init<const PySysLinkBase::SignalValue<std::complex<double> > &>(),
            nb::arg("other"))
        .def("clone",
            &PySysLinkBase::SignalValue<std::complex<double> >::clone)
        .def("get_type_id",
            &PySysLinkBase::SignalValue<std::complex<double> >::GetTypeId)
        .def("get_payload",
            &PySysLinkBase::SignalValue<std::complex<double> >::GetPayload)
        .def("set_payload",
            &PySysLinkBase::SignalValue<std::complex<double> >::SetPayload, nb::arg("new_payload"))
        ;


    auto pyClassISimulationBlock =
        nb::class_<PySysLinkBase::ISimulationBlock, PySysLinkBase::ISimulationBlock_trampoline>
            (m, "ISimulationBlock", "")
        .def("get_id",
            &PySysLinkBase::ISimulationBlock::GetId)
        .def("get_name",
            &PySysLinkBase::ISimulationBlock::GetName)
        .def(nb::init<std::map<std::string, ConfigurationValue>, std::shared_ptr<PySysLinkBase::IBlockEventsHandler> >(),
            nb::arg("block_configuration"), nb::arg("block_events_handler"))
        .def("get_sample_time",
            &PySysLinkBase::ISimulationBlock::GetSampleTime)
        .def("set_sample_time",
            &PySysLinkBase::ISimulationBlock::SetSampleTime, nb::arg("sample_time"))
        .def("get_input_ports",
            &PySysLinkBase::ISimulationBlock::GetInputPorts)
        .def("get_output_ports",
            &PySysLinkBase::ISimulationBlock::GetOutputPorts)
        .def("compute_outputs_of_block",
            &PySysLinkBase::ISimulationBlock::ComputeOutputsOfBlock, nb::arg("sample_time"), nb::arg("current_time"), nb::arg("is_minor_step") = false)
        .def("_compute_outputs_of_block",
            &PySysLinkBase::ISimulationBlock::_ComputeOutputsOfBlock, nb::arg("sample_time"), nb::arg("current_time"), nb::arg("is_minor_step") = false)
        .def("is_block_free_source",
            &PySysLinkBase::ISimulationBlock::IsBlockFreeSource)
        .def("is_input_direct_block_chain_end",
            &PySysLinkBase::ISimulationBlock::IsInputDirectBlockChainEnd, nb::arg("input_index"))
        .def("notify_event",
            &PySysLinkBase::ISimulationBlock::NotifyEvent, nb::arg("block_event"))
        .def("try_update_configuration_value",
            &PySysLinkBase::ISimulationBlock::TryUpdateConfigurationValue, nb::arg("key_name"), nb::arg("value"))
        .def("_try_update_configuration_value",
            &PySysLinkBase::ISimulationBlock::_TryUpdateConfigurationValue, nb::arg("key_name"), nb::arg("value"))
        .def_static("find_block_by_id",
            &PySysLinkBase::ISimulationBlock::FindBlockById, nb::arg("id"), nb::arg("blocks_to_find"))
        .def("register_read_inputs_callbacks",
            &PySysLinkBase::ISimulationBlock::RegisterReadInputsCallbacks, nb::arg("callback"))
        .def("register_calculate_output_callbacks",
            &PySysLinkBase::ISimulationBlock::RegisterCalculateOutputCallbacks, nb::arg("callback"))
        .def("register_update_configuration_value_callbacks",
            &PySysLinkBase::ISimulationBlock::RegisterUpdateConfigurationValueCallbacks, nb::arg("callback"))
        .def("get_events",
            &PySysLinkBase::ISimulationBlock::GetEvents, nb::arg("sample_time"), nb::arg("event_time"), nb::arg("event_time_states"), nb::arg("include_known_events") = false)
        .def("get_known_events",
            &PySysLinkBase::ISimulationBlock::GetKnownEvents, nb::arg("resolved_sample_time"), nb::arg("simulation_start_time"), nb::arg("simulation_end_time"))
        ;


    auto pyClassSolverFactory =
        nb::class_<PySysLinkBase::SolverFactory>
            (m, "SolverFactory", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("create_ode_step_solver",
            &PySysLinkBase::SolverFactory::CreateOdeStepSolver, nb::arg("solver_configuration"))
        ;


    auto pyClassIBlockFactory =
        nb::class_<PySysLinkBase::IBlockFactory, PySysLinkBase::IBlockFactory_trampoline>
            (m, "IBlockFactory", "")
        .def(nb::init<>()) // implicit default constructor
        .def("create_block",
            &PySysLinkBase::IBlockFactory::CreateBlock, nb::arg("block_configuration"), nb::arg("block_events_handler"))
        ;


    auto pyClassOutputPort =
        nb::class_<PySysLinkBase::OutputPort, PySysLinkBase::Port>
            (m, "OutputPort", "")
        .def(nb::init<std::shared_ptr<PySysLinkBase::UnknownTypeSignalValue> >(),
            nb::arg("value"))
        ;


    auto pyClassInputPort =
        nb::class_<PySysLinkBase::InputPort, PySysLinkBase::Port>
            (m, "InputPort", "")
        .def(nb::init<bool, std::shared_ptr<PySysLinkBase::UnknownTypeSignalValue> >(),
            nb::arg("has_direct_feedthrough"), nb::arg("value"))
        .def("has_direct_feedthrough",
            &PySysLinkBase::InputPort::HasDirectFeedthrough)
        ;


    auto pyClassPortLink =
        nb::class_<PySysLinkBase::PortLink>
            (m, "PortLink", "")
        .def(nb::init<std::shared_ptr<PySysLinkBase::ISimulationBlock>, std::shared_ptr<PySysLinkBase::ISimulationBlock>, int, int>(),
            nb::arg("origin_block"), nb::arg("sink_block"), nb::arg("origin_block_port_index"), nb::arg("sink_block_port_index"))
        .def_rw("origin_block", &PySysLinkBase::PortLink::originBlock, "")
        .def_rw("sink_block", &PySysLinkBase::PortLink::sinkBlock, "")
        .def_rw("origin_block_port_index", &PySysLinkBase::PortLink::originBlockPortIndex, "")
        .def_rw("sink_block_port_index", &PySysLinkBase::PortLink::sinkBlockPortIndex, "")
        .def_static("parse_from_config",
            &PySysLinkBase::PortLink::ParseFromConfig, nb::arg("link_configuration"), nb::arg("blocks"))
        ;


    auto pyClassISimulationBlockWithContinuousStates =
        nb::class_<PySysLinkBase::ISimulationBlockWithContinuousStates, PySysLinkBase::ISimulationBlock, PySysLinkBase::ISimulationBlockWithContinuousStates_trampoline>
            (m, "ISimulationBlockWithContinuousStates", "")
        .def(nb::init<std::map<std::string, ConfigurationValue>, std::shared_ptr<PySysLinkBase::IBlockEventsHandler> >(),
            nb::arg("block_configuration"), nb::arg("block_events_handler"))
        .def("get_continuous_states",
            &PySysLinkBase::ISimulationBlockWithContinuousStates::GetContinuousStates)
        .def("set_continuous_states",
            &PySysLinkBase::ISimulationBlockWithContinuousStates::SetContinuousStates, nb::arg("new_states"))
        .def("get_continuous_state_derivatives",
            &PySysLinkBase::ISimulationBlockWithContinuousStates::GetContinuousStateDerivatives, nb::arg("sample_time"), nb::arg("current_time"))
        ;


    auto pyClassBlockTypeSupportPluginLoader =
        nb::class_<PySysLinkBase::BlockTypeSupportPluginLoader>
            (m, "BlockTypeSupportPluginLoader", "")
        .def(nb::init<>()) // implicit default constructor
        .def("load_plugins",
            &PySysLinkBase::BlockTypeSupportPluginLoader::LoadPlugins, nb::arg("plugin_directory"), nb::arg("plugin_configuration"))
        ;


    auto pyClassSimulationModel =
        nb::class_<PySysLinkBase::SimulationModel>
            (m, "SimulationModel", "")
        .def_rw("simulation_blocks", &PySysLinkBase::SimulationModel::simulationBlocks, "")
        .def_rw("port_links", &PySysLinkBase::SimulationModel::portLinks, "")
        .def_rw("block_events_handler", &PySysLinkBase::SimulationModel::blockEventsHandler, "")
        .def(nb::init<std::vector<std::shared_ptr<PySysLinkBase::ISimulationBlock> >, std::vector<std::shared_ptr<PySysLinkBase::PortLink> >, std::shared_ptr<PySysLinkBase::IBlockEventsHandler> >(),
            nb::arg("simulation_blocks"), nb::arg("port_links"), nb::arg("block_events_handler"))
        .def("get_connected_ports",
            &PySysLinkBase::SimulationModel::GetConnectedPorts, nb::arg("origin_block"), nb::arg("output_port_index"))
        .def("get_connected_blocks",
            &PySysLinkBase::SimulationModel::GetConnectedBlocks, nb::arg("origin_block"), nb::arg("output_port_index"))
        .def("get_origin_block",
            &PySysLinkBase::SimulationModel::GetOriginBlock, nb::arg("sink_block"), nb::arg("input_port_index"))
        .def("get_direct_block_chains",
            &PySysLinkBase::SimulationModel::GetDirectBlockChains)
        .def("order_block_chains_onto_free_order",
            &PySysLinkBase::SimulationModel::OrderBlockChainsOntoFreeOrder, nb::arg("direct_block_chains"))
        .def("propagate_sample_times",
            &PySysLinkBase::SimulationModel::PropagateSampleTimes)
        ;


    auto pyClassBasicOdeSolver =
        nb::class_<PySysLinkBase::BasicOdeSolver>
            (m, "BasicOdeSolver", "")
        .def_rw("first_time_step", &PySysLinkBase::BasicOdeSolver::firstTimeStep, "")
        .def("system_model",
            &PySysLinkBase::BasicOdeSolver::SystemModel, nb::arg("states"), nb::arg("time"))
        .def("system_model_jacobian",
            &PySysLinkBase::BasicOdeSolver::SystemModelJacobian, nb::arg("states"), nb::arg("time"))
        .def(nb::init<std::shared_ptr<PySysLinkBase::IOdeStepSolver>, std::shared_ptr<PySysLinkBase::SimulationModel>, std::vector<std::shared_ptr<PySysLinkBase::ISimulationBlock> >, std::shared_ptr<PySysLinkBase::SampleTime>, std::shared_ptr<PySysLinkBase::SimulationOptions>, double, bool, double>(),
            nb::arg("ode_step_solver"), nb::arg("simulation_model"), nb::arg("simulation_blocks"), nb::arg("sample_time"), nb::arg("simulation_options"), nb::arg("first_time_step") = 1e-6, nb::arg("activate_events") = true, nb::arg("event_tolerance") = 1e-2)
        .def("update_states_to_next_time_hits",
            &PySysLinkBase::BasicOdeSolver::UpdateStatesToNextTimeHits)
        .def("do_step",
            &PySysLinkBase::BasicOdeSolver::DoStep, nb::arg("current_time"), nb::arg("time_step"))
        .def("compute_major_outputs",
            &PySysLinkBase::BasicOdeSolver::ComputeMajorOutputs, nb::arg("current_time"))
        .def("get_next_time_hit",
            &PySysLinkBase::BasicOdeSolver::GetNextTimeHit)
        .def("get_next_suggested_time_step",
            &PySysLinkBase::BasicOdeSolver::GetNextSuggestedTimeStep)
        ;


    auto pyClassModelParser =
        nb::class_<PySysLinkBase::ModelParser>
            (m, "ModelParser", "")
        .def(nb::init<>()) // implicit default constructor
        .def_static("yaml_to_configuration_value",
            &PySysLinkBase::ModelParser::YamlToConfigurationValue, nb::arg("node"))
        .def_static("parse_from_yaml",
            &PySysLinkBase::ModelParser::ParseFromYaml, nb::arg("filename"), nb::arg("block_factories"), nb::arg("block_events_handler"))
        ;


    auto pyClassSimulationManager =
        nb::class_<PySysLinkBase::SimulationManager>
            (m, "SimulationManager", "")
        .def(nb::init<std::shared_ptr<PySysLinkBase::SimulationModel>, std::shared_ptr<PySysLinkBase::SimulationOptions> >(),
            nb::arg("simulation_model"), nb::arg("simulation_options"))
        .def("run_simulation",
            &PySysLinkBase::SimulationManager::RunSimulation)
        .def("run_simulation_step",
            &PySysLinkBase::SimulationManager::RunSimulationStep)
        .def("get_simulation_output",
            &PySysLinkBase::SimulationManager::GetSimulationOutput)
        ;
    // #endif
    ////////////////////    </generated_from:test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

}
